#+TITLE: Implementation of Type Theory based on dependent Inductive and Coinductive Types
#+AUTHOR: Florian Engel
#+OPTIONS: toc:nil
#+options: H:1
#+latex_class: beamer
#+columns: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+beamer_theme: default
#+beamer_color_theme:
#+beamer_font_theme:
#+beamer_inner_theme:
#+beamer_outer_theme:
#+beamer_header: \input{headerSlides}

* Inductive types
  + defined over their constructors
  + each constructor has to give back this type
** Examples
   + Booleans
     #+begin_example
     data Bool : Set where
       True : Unit $\rat$ Bool
       False : Unit $\rat$ Bool
     #+end_example
   + Natural numbers
     #+begin_example
     data Nat : Set where
       Zero : Unit $\rat$ Nat
       Succ : Nat $\rat$ Nat
     #+end_example
* Destructing inductive types
  + also called recursion
  + pattern matches on the constructor
  + gives back values of same type in each match
** Examples
   + negation
     #+begin_example
     rec Bool to Bool where
       True u = False @ $\lozenge$
       False u = True @ $\lozenge$
     #+end_example
   + isZero
     #+begin_example
     rec Nat to Bool where
       Zero u = True @ $\lozenge$
       Succ n = False @ $\lozenge$ 
     #+end_example
* postive coinductive types
  + treats recursive occurence like a value
  + otherwise like inductive types
  + functions which produce such types have to be productive
** Example
   + Stream in coq
     #+begin_src coq
       CoInductive Stream (A : Set) : Set :=
         Cons : A -> Stream A -> Stream A.
     #+end_src
   + repeat function
     #+begin_src coq
       CoFixpoint repeat (A : Set) (x : A) : Stream A :=
         Cons A x (repeat A x).
     #+end_src
* What is wrong about positve coinductive types
  + Symmetry with inductive types not clear
  + Breaks subject reduction
    + Subject reduction: types are preserved after reduction

* Ourys Example
   #+begin_src coq
    CoInductive U : Set := In : U -> U.
   #+end_src
   #+begin_src coq
     CoFixpoint u : U := In u.
   #+end_src
   #+begin_src coq
     Definition force (x: U) : U :=
       match x with
         In y => In y
       end.
   #+end_src
   #+begin_src coq
     Definition eq (x : U) : x = force x :=
       match x with
         In y => eq_refl
       end.
   #+end_src
   #+begin_src coq
     Definition eq_u : u = In u := eq u
   #+end_src



   
* negative coinductive types
  + defined over their destructors
  + functions use copattern matching
** Examples
   + Stream
     #+begin_example
     codata Stream$\langle$A : Set$\rangle$ : Set where
       Hd : Stream $\rat$ A
       Tl : Stream $\rat$ Stream
     #+end_example
   + repeat function
     #+begin_example
     repeat$\langle$A : Set$\rangle$(x : A) =
       corec Unit to Stream$\langle$A$\rangle$ where
         { Hd s = x
         ; Tl s = $\lozenge$ } @ $\lozenge$
     #+end_example

* Symmetry with inductive types
   #+begin_example
   codata Product$\langle$A : Set, B : Set$\rangle$ : Set where
      Fst : Product $\rat$ A
      Snd : Product $\rat$ B
   mkProduct$\langle$A : Set, B : Set$\rangle$ (x:A, y:B) =
     corec Unit to Product<A,B> where
       { Fst u $\rat$ x
       ; Snd u $\rat$ y } @ $\lozenge$
   #+end_example
   #+begin_example
   data Product$\langle$A,B$\rangle$ : Set where
      MkProduct : (x : A) $\rat$ B $\rat$ Product
   fst$\langle$A : Set, B : Set$\rangle$  =
     rec Product<A,B> to A where
        { MkProduct x y = x }
   snd$\langle$A : Set, B : Set$\rangle$  =
     rec Product<A,B> to B where
        { MkProduct x y = y }
   #+end_example
   

* Type Theory based on dependent Inductive and Coinductive Types
  + kinds: $(x_1:A_1,\dots,x_n:A_n)\rat*$
  + types: $(x_1:A_1,\dots,x_n:A_n)\rat B$
  + lambda abstraction: $(x).A$
  + type application: $A@t$
  + term application: $t@s$
  + inductive types: $\mu(X:\Gamma\rat*;\vv{\sigma};\vec{A})$
  + coinductive types $\nu(X:\Gamma\rat*;\vv{\sigma};\vec{A})$
  + recursion: rec $\vv{(\Gamma_k,y_k).g_k}$
  + corecursion: corec $\vv{(\Gamma_k,y_k).g_k}$

* Dependent coinductive types
  + Partial streams whitch depend on their defintion depth
    #+begin_example
    codata PStr$\langle$A : Set$\rangle$ : (n : Conat) $\rat$ Set where
      Hd : (k : Conat) $\rat$ PStr (succ @ k) $\rat$ A
      Tl : (k : Conat) $\rat$ PStr (succ @ k) $\rat$ PStr @ k
    #+end_example
  + Dependent funcitions 
    #+begin_example
    codata Pi$\langle$A : Set, B : (x : A) $\rat$ Set$\rangle$ : Set where
      Inst : (x : A) $\rat$ Pi $\rat$ B @ x
    #+end_example


* 
  #+begin_center
  \Huge Demo
  #+end_center

* Other topics in the thesis
+ Termination and productivity checking with sized types
+ Implementation details
  + Rules rewritting
  + De-Brujin indexes
