* Statements
  /statement/ =
    *data* /Name/ $C_1\dots C_n$ $(x_1 : B_1,\dots,x_n : B_n)$ -> Set where
      $Constr_1$ : $(x_{1_1}:B_{1_1},\dots,x_{n_1}: B_{n_1})$ -> $A_1[Name/X]$ -> /Name/ $\sigma_{1_1}\dots \sigma_{1_n}$
             $\vdots$                $\vdots$             $\vdots$            $\vdots$
      $Constr_m$ : $(x_{1_m}:B_{1_m},\dots,x_{n_m}: B_{n_m})$ -> $A_i[Name/X]$ -> /Name/ $\sigma_{m_1}\dots \sigma_{m_n}$
   \|
    *codata* /Name/ $C_1\dots C_n$ $(x_1 : B_1,\dots,x_n : B_n)$ -> Set where
      $Destr_1$ : $(x_{1_1}:B_{i_1},\dots,x_{n_1}: B_{n_1})$ -> /Name/ $\sigma_{1_1}\dots \sigma_{1_n}$ -> $A_1[Name/X]$
             $\vdots$                $\vdots$             $\vdots$            $\vdots$
      $Destr_m$ : $(x_{1_m}:B_{1_m},\dots,x_{n_m}: B_{n_m})$ -> /Name/ $\sigma_{m_1}\dots \sigma_{m_n}$ -> $A_i[Name/X]$
   \| /name/ $x_1 \dots x_n$ = /expr/

  "/Name/" , "$Constr_1\dots Contr_m$" and "$Destr_1\dots Destr_m$" are arbitrary distinct names

  The statements correspond to $\rho(X:\Gamma\rightarrow*;\vec\sigma;\vec{A}):\Gamma\rightarrow*$ as follows.
  + $x_1: B_1,\dots,x_n: B_n$ is $\Gamma$
  + /Name/ is X
  + $Constr_1,\dots, Contr_m$ stands for $\alpha_1^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)},\dots,\alpha_m^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vecA)}$
  + $Destr_1,\dots, Destr_m$ stands for $\xi_1^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)},\dots,\xi_m^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)}$
  + $Name_i$ is $A_i[\Gamma/X]$
  + $(x_{1_1}:B_{1_1},\dots,x_{n_1}: B_{n_1}),\dots,(x_{1_m}:B_{1_m},\dots,x_{n_m}:B_{n_m})$ stands for $\Gamma_1,\dots,\Gamma_m$
  + $C_1\dots C_n$ have to be of *, they are for polymorphism.  If we call a constructor we have to give this types,
    to relate the right type to it.

  We take $B_1\rightarrow\dots\rightarrow B_n)$ as syntactic sugar for $(\_:B_1,\dots,\_:B_n)$ where _ stands for a unused termvariable

  We will also need a extra context which relates constructors to their types
* (Co)rec
  /expr/ =
    rec C where
      $Constr_1$  $x_{1_1}$ $\dots$ $x_{n_1}$ $y_1$ = $g_1$
         $\vdots$      $\vdots$      $\vdots$        $\vdots$
      $Constr_m$  $x_{1_m}$ $\dots$ $x_{n_m}$ $y_m$ = $g_m$
  \|
    corec C where
      $Destr_1$  $x_{1_1}$ $\dots$ $x_{n_1}$ $y_1$ = $g_1$
         $\vdots$      $\vdots$      $\vdots$        $\vdots$
      $Destr_m$  $x_{1_m}$ $\dots$ $x_{n_m}$ $y_m$ = $g_m$
  \| /expr/ @ /expr/ \| () | Unit \| /Constr/ /expr/\* \| /Destr/ /expr/\*

  $t_1,\dots,t_m,g_1,\dots,g_k are /expr/
  $x_{1_1},\dots, x_{n_m}$ are termvariables
* Terminal Object
  *codata* Terminal : Set where
     Terminal : Terminal -> Terminal
  terminal' = (corec (y:Unit) where
                 Terminal x = x) @ ()
     
* Intial Object
  *data* Initial : Set where
     Initial : Intial -> Intial
  edfalsum = rec (y:Initial) where
                 Initial x = x

* Natural Numbers
  *data* Nat : Set where
     Zero' : Terminal -> Nat
     Succ : Nat -> Nat
  zero = Zero'

* Binary Product
  *codata* Product A B : Set where
     Fst : Product -> A
     Snd : Product -> B
  pair x y = (corec Unit where
                Fst _ -> x
                Snd _ -> y) @ ()

* Binary Coproduct
  *data* Coproduct A B : Set where
     Left : A -> Coproduct
     Right : B -> Coproduct
  coproduct x y C = rec C where
                      Left _ -> x
                      Right _ -> y

* Pi Type
  *codata* Pi A B : Set where
     Apply' : (x: A) -> Pi -> B @ x
  lambda A B x g = (corec Unit where
                      Apply' A B x _ = g) @ ()
  apply t x = Apply' x t

* List
  List A =  $\nu(X:*;\epsilon_2;(\textbf{1},X))$
  + $\Gamma_1=\emptyset$
  + $\Gamma_2=A$

  *data* List A : Set where
     Nil : Terminal -> List
     Cons : A -> List -> List

$(A_1)(A_2)\ny(X:\Gamma\rightarrow*;(id_\Gamma,id_\Gamma);(A_1,A_2))@id_\Gamma : *$

* Rose Tree
  Rose Tree A = $\nu(X:*;\epsilon_2;(\textbf{1},List X)

  *data* RoseTree A : Set where
     Leaf : Terminal -> RoseTree
     Branch : List RoseTree -> RoseTree
