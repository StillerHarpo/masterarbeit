#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{bussproofs}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \lstset{
#+LATEX_HEADER:  basicstyle=\ttfamily,
#+LATEX_HEADER:   mathescape
#+LATEX_HEADER: }
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER:\newenvironment{scprooftree}[1]%
#+LATEX_HEADER:  {\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
#+LATEX_HEADER:  {\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }
#+TITLE: Masterarbeit
* Abstract Syntax
** Statements
   \begin{lstlisting}
   statement =
     data Name : $(x_1 : B_1,\dots,x_n : B_n)$ -> Set where
       $Constr_1$ : $(x_{1_1}:B_{1_1},\dots,x_{n_1}: B_{n_1})$ -> $A_1[Name/X]$ -> Name $\sigma_{1_1}\dots \sigma_{1_n}$
              $\vdots$                $\vdots$             $\vdots$            $\vdots$
       $Constr_m$ : $(x_{1_m}:B_{1_m},\dots,x_{n_m}: B_{n_m})$ -> $A_i[Name/X]$ -> Name $\sigma_{m_1}\dots \sigma_{m_n}$
    | codata Name : $(x_1 : B_1,\dots,x_n : B_n)$ -> Set where
       $Destr_1$ : $(x_{1_1}:B_{i_1},\dots,x_{n_1}: B_{n_1})$ -> Name $\sigma_{1_1}\dots \sigma_{1_n}$ -> $A_1[Name/X]$
              $\vdots$                $\vdots$             $\vdots$            $\vdots$
       $Destr_m$ : $(x_{1_m}:B_{1_m},\dots,x_{n_m}: B_{n_m})$ -> Name $\sigma_{m_1}\dots \sigma_{m_n}$ -> $A_i[Name/X]$
    | name<C_1,\dots,C_n> $x_1:A_1 \dots x_n:A_n$ = expr
   \end{lstlisting}

   "/Name/" , "$Constr_1\dots Contr_m$" and "$Destr_1\dots Destr_m$" are arbitrary distinct names

   The statements correspond to $\rho(X:\Gamma\rightarrow*;\vec\sigma;\vec{A}):\Gamma\rightarrow*$ as follows.
   + $x_1: B_1,\dots,x_n: B_n$ is $\Gamma$
   + /Name/ is X
   + $Constr_1,\dots, Contr_m$ stands for $\alpha_1^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)},\dots,\alpha_m^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)}$
   + $Destr_1,\dots, Destr_m$ stands for $\xi_1^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)},\dots,\xi_m^{\mu(X:\Gamma\rightarrow *;\vec\sigma;\vec A)}$
   + $Name_i$ is $A_i[\Gamma/X]$
   + $(x_{1_1}:B_{1_1},\dots,x_{n_1}: B_{n_1}),\dots,(x_{1_m}:B_{1_m},\dots,x_{n_m}:B_{n_m})$ stands for $\Gamma_1,\dots,\Gamma_m$
   + $C_1\dots C_n$ have to be of *, they are for polymorphism.  If we call a constructor we have to give this types,
     to relate the right type to it.

   We take $B_1\rightarrow\dots\rightarrow B_n$ as syntactic sugar for $(\_:B_1,\dots,\_:B_n)$ where _ stands for a unused termvariable

   We will also need a extra context which relates constructors to their types

** Expressions
   \begin{lstlisting}
   expr =
     rec $\mu$ to C where
       $Constr_1$ $x_{1_1}$ $\dots$ $x_{n_1}$ $y_1$    = $g_1$
               $\vdots$          $\vdots$
       $Constr_m$ $x_{1_m}$ $\dots$ $x_{n_m}$ $y_m$ = $g_m$
   | corec C to $\nu$ where
       $Destr_1$ $x_{1_1}$ $\dots$ $x_{n_1}$ $y_1$   = $g_1$
               $\vdots$         $\vdots$
       $Destr_m$  $x_{1_m}$ $\dots$ $x_{n_m}$ $y_m$ = $g_m$
   | expr @ expr | () | Unit | Constr expr* | Destr expr*
   \end{lstlisting}

   $g_1,\dots,g_k$ are /expr/

   $x_{1_1},\dots, x_{n_m}$ are termvariables

** Terminal Object
   #+begin_example
   codata Terminal : Set where
      Terminal : Terminal -> Terminal
   terminal' = (corec Unit where
                  Terminal x = x) @ ()

   #+end_example
** Intial Object
   #+begin_example
   data Initial : Set where
      Initial : Intial -> Intial
   edfalsum = rec Initial where
                Initial x = x
   #+end_example

** Natural Numbers
   #+begin_example
   data Nat : Set where
      Zero' : Terminal -> Nat
      Succ : Nat -> Nat
   zero = Zero' @ ()
   #+end_example
** Binary Product
   #+begin_example
   codata Product A B : Set where
      Fst : Product -> A
      Snd : Product -> B
   pair x y = (corec Unit where
                 Fst _ -> x
                 Snd _ -> y) @ ()
   #+end_example
** Binary Coproduct
   #+begin_example
   data Coproduct<A,B> : Set where
      Left : A -> Coproduct
      Right : B -> Coproduct
   #+end_example
** Pi Type
   #+begin_example
   codata Pi<A,B>: Set where
      Apply' : (x: A) -> Pi -> B
   lambda<A,B> (x:A, g:B) = (corec Unit where
                              Apply'<A,B> x _ = g) @ ()
   apply<A,B> (t:A, x:B) = Apply' x t
   #+end_example
** Sigma Type
   #+begin_example
   data Sigma A B : Set where
      Exists : (x:A) -> B -> Sigma
   #+end_example
** Vectors
   #+begin_example
   data Vector A : (n:Nat) -> Set where
     Nil' : Unit -> Vector 0
     Cons : (k:Nat) -> Product A (Vector k) -> Vector (Succ k)
   nil A = Nil'<A> @ ()
   #+end_example
** Extended Naturals
   #+begin_example
   codata ExNat : Set where
      Prec : ExNat -> Coproduct<Unit,ExNat>
   succE = corec ExNat where
             Prec x -> Right x
   #+end_example
** Streams
   #+begin_example
   codata PStr<A>: (n: ExNat) -> Set where
      hd : (k : ExNat) -> PStr A (succE k) -> A
      tl : (k : ExNat) -> PStr A (succE k) -> PStr A k
   #+end_example
** List
   List A =  $\nu(X:*;\epsilon_2;(\textbf{1},X))$
   + $\Gamma_1=\emptyset$
   + $\Gamma_2=A$

   #+begin_example
   data List<A> : Set where
      Nil : Terminal -> List
      Cons : A -> List -> List
   nil A = Nil<A> @ ()
   #+end_example

** Length function on lists of Units
   \begin{align*}
   \text{length} = \text{rec} &((y_k:\top).\alpha_1^\textbf{N}@\langle\rangle\\
                &,(x:\top,y_k:\mu(X:*;\epsilon_2(\mathbf{1},X)))).\alpha_2^\textbf{N} @ y_k\\
   \end{align*}
*** Type checking

\begin{scprooftree}{0.6}
\AxiomC{$\vdash\textbf{N}:*$}
\AxiomC{$\vdash\alpha_1^\textbf{N}: (x:\textbf{1})\rightarrow\textbf{N}$}
\RightLabel{\textbf{(Term-Weak)}}
\UnaryInfC{$y_k:\textbf{1}\vdash\alpha_1^\textbf{N}: (x:\textbf{1})\rightarrow\textbf{N}$}
\AxiomC{$\vdash\langle\rangle':\textbf{1}$}
\RightLabel{\textbf{(Term-Weak)}}
\UnaryInfC{$y_k:\textbf{1}\vdash\langle\rangle':\textbf{1}$}
\RightLabel{\textbf{(Inst)}}
\BinaryInfC{$y_k:\textbf{1}\vdash \alpha_1^\textbf{N}@\langle\rangle':\textbf{N}$}
\AxiomC{$\vdash\alpha_2^\textbf{N}: (x:\textbf{N})\rightarrow\textbf{N}$}
\RightLabel{\textbf{(Term-Weak)}}
\UnaryInfC{$y_k:\textbf{N}\vdash\alpha_2^\textbf{N}: (x:\textbf{N})\rightarrow\textbf{N}$}
\AxiomC{$\textbf{N}:*$}
\RightLabel{\textbf{(Proj)}}
\UnaryInfC{$y_k:\textbf{N}\vdash y_k:\textbf{N}$}
\RightLabel{\textbf{(Inst)}}
\BinaryInfC{$y_k:\textbf{N}\vdash \alpha_2^\textbf{N}@y_k:\textbf{N}$}
\RightLabel{\textbf{(Ind-E)}}
\TrinaryInfC{$\vdash \text{rec}((y_k).\alpha_1^\textbf{N}@\langle\rangle'
                ,(y_k).\alpha_2^\textbf{N} @ y_k):(y:\text{List }\textbf{1})\rightarrow\textbf{N}$}
\end{scprooftree}

** Rose Tree
   Rose Tree A = $\nu(X:*;\epsilon_2;(\textbf{1},List X)$

   #+begin_example
   data RoseTree<A> : Set where
      Leaf : Terminal -> RoseTree
      Branch : List<RoseTree> -> RoseTree
   leaf A = Leaf<A> @ ()
   #+end_example

* Typing rules
  We have to rewrite the typing rules of the paper, to get rules which are
  syntax directed. Here are the rules which have to be rewritten.
  + *(Ty-Inst)*
  + *(Param-Abstr)*
  This rules contain variables in the premises where their type isn't in the
  conclusion. So if we want to type-check something which is the conclusion of
  such a rule we have no way of knowing what this variables are.

  We don't need the weaking rules because we can lookup a variable in a
  context.

  So the following rules get removed.
  + *(TyVar-Weak)*
  + *(Ty-Weak)*
  The order in *TyCtx* isn't relevant so we use a Map for it.  The order
  of *Ctx* is relevant because types of later variables can refer to
  former variables and application instantiate the first varibale in
  *Ctx*

  We also rewrite the rules which are already syntax-directed to rules
  which work on our syntax

  We add a new Ctx for data types

  We will mark semantic differences in the rewritten rules gray.
** Context rules
   The rules for valid contexts are already syntax directed so we take
   just them
   \begin{center}
   \AxiomC{}
   \UnaryInfC{$\vdash\emptyset$ \textbf{TyCtx}}
   \DisplayProof
   \hskip 1.5em
   \AxiomC{$\vdash\Theta$ \textbf{TyCtx}}
   \AxiomC{$\vdash\Gamma$ \textbf{Ctx}}
   \BinaryInfC{$\vdash\Theta,X:\Gamma\rightarrow*$ \textbf{TyCtx}}
   \DisplayProof
   \vskip 0.5em
   \AxiomC{}
   \UnaryInfC{$\vdash\emptyset$ \textbf{Ctx}}
   \DisplayProof
   \hskip 1.5em
   \AxiomC{$\emptyset|\Gamma\vdash A:*$}
   \UnaryInfC{$\vdash\Gamma,x:A$ \textbf{Ctx}}
   \DisplayProof
   \end{center}

   We use the notation $\Theta(X)\rightsquigarrow\Gamma\rightarrow*$ for
   looking up the type-variable $X$ in type-context $\Theta$ yields type
   $\Gamma\rightarrow*$. We add 2 rules for looking up something in a
   type-context.  They are:
   \begin{center}
     \AxiomC{$\vdash \Theta$ \textbf{TyCtx}}
     \AxiomC{$\vdash \Gamma$ \textbf{Ctx}}
     \BinaryInfC{$\Theta,X:\Gamma\rightarrow*(X)\rightsquigarrow\Gamma\rightarrow*$}
     \DisplayProof
     \hskip 1.5em
     \AxiomC{$\vdash \Gamma_1$ \textbf{Ctx}}
     \AxiomC{$\Theta(X) \rightsquigarrow\Gamma_2\rightarrow*$}
     \BinaryInfC{$\Theta,Y:\Gamma_1\rightarrow*(X)\rightsquigarrow\Gamma_2\rightarrow*$}
     \DisplayProof
   \end{center}
   Here $Y$ and $X$ are different variables

   Respectively the notation $\Gamma(x)\rightsquigarrow A$ means looking
   up the termvariable $x$ in term-context $\Gamma$ yields type $A$. The
   rules for term-contexts are:
   \begin{center}
     \AxiomC{$\vdash \Gamma$ \textbf{Ctx}}
     \AxiomC{$\Gamma\vdash A:*$}
     \BinaryInfC{$\Gamma,x:A(x)\rightsquigarrow A$}
     \DisplayProof
     \hskip 1.5em
     \AxiomC{$\Gamma(x) \rightsquigarrow A$}
     \AxiomC{$\Gamma\vdash B:*$}
     \BinaryInfC{$\Gamma,y:B(x)\rightsquigarrow A$}
     \DisplayProof
   \end{center}

** Full evaluation
   We write $A \longrightarrow_T^* B$ for evaluating $A$ as long as it
   is possible yields $B$.
** Beta-equivalence
   We introduce a new rule for beta-equivalence.
   \begin{center}
   \AxiomC{$A\longrightarrow_T^* A'$}
   \AxiomC{$B\longrightarrow_T^* B'$}
   \AxiomC{$A'\equiv_\alpha B'$}
   \TrinaryInfC{$A\equiv_\beta B$}
   \DisplayProof
   \end{center}
   In the implementation $\equiv_\alpha$ is trivial, because we use /de
   Bruijn indices/.

   We also add some rule to check if two contexts are the same.
   \begin{center}
   \AxiomC{}
   \UnaryInfC{$\emptyset\equiv_\beta\emptyset$}
   \DisplayProof
   \hskip 1.5em
   \AxiomC{$\Gamma_1\equiv_\beta \Gamma_2$}
   \AxiomC{$A[\Gamma_1]\equiv_\beta B[\Gamma_2]$}
   \BinaryInfC{$\Gamma_1,x:A\equiv_\beta\Gamma_2,y:B$}
   \DisplayProof
%   \vskip 0.5em
%   \AxiomC{$\Theta_1\equiv_\beta \Theta_2$}
%   \AxiomC{$\Gamma_1\equiv_\beta \Gamma_2$}
%   \BinaryInfC{$\Theta_1,X:\Gamma_1\rightarrow*\equiv_\beta\Theta_2,X:\Gamma_2\rightarrow*$}
%   \DisplayProof
   \end{center}
   \end{center}

** Unit type introduction
   The rule
   \begin{prooftree}
     \AxiomC{}
     \RightLabel{\textbf{($\top$-I)}}
     \UnaryInfC{$\vdash\top:*$}
   \end{prooftree}
   gets rewritten to
    \begin{prooftree}
     \AxiomC{}
     \RightLabel{\textbf{(Unit-I)}}
     \UnaryInfC{\colorbox{gray}{$\Theta|\Gamma$}$\vdash$Unit:$*$}
   \end{prooftree}
   We change the syntax "$\top$" to "Unit" and add *Ctx* and *TyCtx*.
   We will do this for every rule which has empty contexts to subsume
   the rules with *TyVar-Weak*, *Ty-Weak* and *Term-Weak*.

** Type Variable introduction

    The rule
    \begin{prooftree}
     \AxiomC{$\vdash \Theta$ \textbf{TyCtx}}
     \AxiomC{$\vdash \Gamma$ \textbf{Ctx}}
     \RightLabel{\textbf{(TyVar-I)}}
     \BinaryInfC{$\Theta,X:\Gamma\rightarrow*|\emptyset\vdash X : \Gamma \rightarrow *$}
   \end{prooftree}
   gets rewritten to

    \begin{prooftree}
     \AxiomC{\colorbox{gray}{$\Theta(X)\rightsquigarrow\Gamma'\rightarrow*$}}
     \AxiomC{\colorbox{gray}{$\vdash \Gamma_1$ \textbf{Ctx}}}
     \AxiomC{\colorbox{gray}{$\Gamma'\equiv_\beta\Gamma$}}
     \RightLabel{\textbf{(TyVar-I)}}
     \TrinaryInfC{$\Theta|$\colorbox{gray}{$\Gamma_1$}$\vdash X : \Gamma \rightarrow *$}
   \end{prooftree}

** Type instantiation
   The rule
   \begin{prooftree}
     \AxiomC{$\Theta|\Gamma_1\vdash A:(x:B,\Gamma_2)\rightarrow*$}
     \AxiomC{$\Gamma_1\vdash t:B$}
     \BinaryInfC{$\Theta|\Gamma_1\vdash A@t:\Gamma_2[t/x]\rightarrow*$}
   \end{prooftree}
   gets rewritten to
    \begin{prooftree}
     \AxiomC{$\Theta|\Gamma_1\vdash A:(x:B,\Gamma_2)\rightarrow*$}
     \AxiomC{$\Gamma_1\vdash t:$\colorbox{gray}{$B'$}}
     \AxiomC{\colorbox{gray}{$B\equiv_\beta B'$}}
     \TrinaryInfC{$\Theta|\Gamma_1\vdash A@t:\Gamma_2[t/x]\rightarrow*$}
   \end{prooftree}


** Parameter abstraction
   The rule
   \begin{center}
     \AxiomC{$\Theta|\Gamma_1,x:A\vdash B:\Gamma_2\rightarrow*$}
     \RightLabel{\textbf{(Param-Abstr)}}
     \UnaryInfC{$\Theta|\Gamma_1\vdash(x).B:(x:A,\Gamma_2)\rightarrow*$}
     \DisplayProof
   \end{center}
   gets rewritten to
   \begin{center}
     \AxiomC{$\Theta|\Gamma_1,x:A\vdash B:\Gamma_2\rightarrow*$}
     \RightLabel{\textbf{(Param-Abstr)}}
     \UnaryInfC{$\Theta|\Gamma_1\vdash(x$\colorbox{gray}{$:A$}$).B:(x:A,\Gamma_2)\rightarrow*$}
     \DisplayProof
   \end{center}

** (co)data definition
   The rule
   \begin{prooftree}
   \AxiomC{$\sigma_k:\Gamma_k\triangleright\Gamma$}
   \AxiomC{$\Theta,X:\Gamma\rightarrow*|\Gamma_k\vdash A_k:*$}
   \RightLabel{(\textbf{FP-Ty})}
   \BinaryInfC{$\Theta | \emptyset \vdash \rho(X : \Gamma \rightarrow *;\vec{\sigma};\vec{A}):\Gamma\rightarrow *$}
   \end{prooftree}
   gets rewritten to
   \begin{prooftree}
   \AxiomC{$\sigma_k:\Gamma_k\triangleright\Gamma$}
   \AxiomC{$\Theta,X:\Gamma\rightarrow*|\Gamma_k\vdash A_k:*$}
   \RightLabel{(\textbf{FP-Ty})}
   \BinaryInfC{$\Theta | $\colorbox{gray}{$\Gamma_1$} $\vdash$ data X $\Gamma$ -> Set where; $\overrightarrow{Constr_k : \Gamma_k\text{ -> }A_k\text{ -> }X \sigma_k}$}
   \end{prooftree}
   and
   \begin{prooftree}
   \AxiomC{$\sigma_k:\Gamma_k\triangleright\Gamma$}
   \AxiomC{$\Theta,X:\Gamma\rightarrow*|\Gamma_k\vdash A_k:*$}
   \RightLabel{(\textbf{FP-Ty})}
   \BinaryInfC{$\Theta |$\colorbox{gray}{$\Gamma_1$} $ \vdash$ codata X $\Gamma$ -> Set where; $\overrightarrow{Destr_k : \Gamma_k \text{ -> } X \sigma_k \text{ -> } A_k}$}
   \end{prooftree}

** Unit expression introduction
   The rule
   \begin{center}
     \AxiomC{}
     \RightLabel{\textbf{(}$\top$\textbf{-I)}}
     \UnaryInfC{$\lozenge:\top$}
     \DisplayProof
   \end{center}
   get rewritten to
   \begin{center}
     \AxiomC{}
     \RightLabel{\textbf{(}$\top$\textbf{-I)}}
     \UnaryInfC{():Unit}
     \DisplayProof
   \end{center}

** Expression Instantiation
   The rule
   \begin{center}
     \AxiomC{$\Gamma_1\vdash t:(x:A,\Gamma_2)\rightarrow B$}
     \AxiomC{$\Gamma_1\vdash s:A$}
     \RightLabel{\textbf{(Inst)}}
     \BinaryInfC{$\Gamma_1\vdash t@s:\Gamma_2[s/x]\rightarrow B[s/x]$}
     \DisplayProof
   \end{center}
   gets rewritten to
   \begin{center}
     \AxiomC{$\Gamma_1\vdash t:(x:A,\Gamma_2)\rightarrow B$}
     \AxiomC{$\Gamma_1\vdash s:$\colorbox{gray}{$A'$}}
     \AxiomC{\colorbox{gray}{$A\equiv_\beta A'$}}
     \RightLabel{\textbf{(Inst)}}
     \TrinaryInfC{$\Gamma_1\vdash t@s:\Gamma_2[s/x]\rightarrow B[s/x]$}
     \DisplayProof
   \end{center}

** Expression variable introduction
   The rule
   \begin{center}
     \AxiomC{$\Gamma\vdash A:*$}
     \RightLabel{\textbf{(Proj)}}
     \UnaryInfC{$\Gamma,x:A\vdash x:A$}
     \DisplayProof
   \end{center}
   gets rewritten to
   \begin{center}
     \AxiomC{\colorbox{gray}{$\Gamma(x)\rightsquigarrow A$}}
     \RightLabel{\textbf{(Proj)}}
     \UnaryInfC{$\Sigma|\Theta|\Gamma\vdash x:A$}
     \DisplayProof
   \end{center}


** Constructor
   The rule
   \begin{center}
     \AxiomC{$\mu(X:\Gamma\rightarrow*;\vec{\sigma};\vec{A}):\Gamma\rightarrow*$}
     \AxiomC{$1\leq k\leq|\vec{A}|$}
     \RightLabel{\textbf{(Ind-I)}}
     \BinaryInfC{$\vdash\alpha_k^{\mu(X:\Gamma\rightarrow*;\vec{\sigma};\vec{A})}:(\Gamma_k,y:A_k[\mu/X])\rightarrow\mu@\sigma_k$}
     \DisplayProof
   \end{center}
   gets rewritten to
   \begin{center}
     \AxiomC{\colorbox{gray}{$\Sigma$(Constr)$\rightsquigarrow(\Gamma_k,y:A_k[\mu/X])\rightarrow\mu@\sigma_k$}}
     \RightLabel{\textbf{(Ind-I)}}
     \UnaryInfC{\colorbox{gray}{$\Sigma|\Theta|\Gamma$}$\vdash$Constr$:(\Gamma_k,y:A_k[\mu/X])\rightarrow\mu@\sigma_k$}
     \DisplayProof
   \end{center}


** Destructor
   The rule
   \begin{center}
     \AxiomC{$\nu(X:\Gamma\rightarrow*;\vec{\sigma};\vec{A}):\Gamma\rightarrow*$}
     \AxiomC{$1\leq k\leq|\vec{A}|$}
     \RightLabel{\textbf{(Coind-E)}}
     \BinaryInfC{$\vdash\xi_k^{\nu(X;\Gamma\rightarrow*;\vec{\sigma};\vec{A})}:(\Gamma_k,y:\nu@\sigma_k)\rightarrow
       A_k[\nu/X]$}
     \DisplayProof
   \end{center}
   gets rewritten to
   \begin{center}
     \AxiomC{\colorbox{gray}{$\Sigma$(Destr)$\rightsquigarrow(\Gamma_k,y:\nu@\sigma_k)\rightarrow
       A_k[\nu/X]$}}
     \RightLabel{\textbf{(Ind-I)}}
     \UnaryInfC{\colorbox{gray}{$\Sigma|\Theta|\Gamma$}$\vdash$Destr$:(\Gamma_k,y:\nu@\sigma_k)\rightarrow
       A_k[\nu/X]$}
     \DisplayProof
   \end{center}


** Recursion
   \begin{center}
     \AxiomC{$\vdash C:\Gamma\rightarrow*$}
     \AxiomC{$\Delta,\Gamma_k,y_k:A_k[C/X]\vdash g_k:(C@\sigma_k)$}
     \AxiomC{$\forall k=1,\dots,n$}
     \RightLabel{\textbf{(Ind-E)}}
     \TrinaryInfC{$\Delta\vdash$ rec
       $\overrightarrow{(\Gamma_k,y_k).g_k}:(\Gamma,y:\mu@id_\Gamma)\rightarrow C@id_\Gamma$}
     \DisplayProof
   \end{center}

   \begin{prooftree}
     \AxiomC{$\vdash C:\Gamma\rightarrow*$}
     \AxiomC{\colorbox{gray}{$\overrightarrow{\vdash B_k\equiv_\beta(C@\sigma_k)}$}}
     \AxiomC{\colorbox{gray}{$\overrightarrow{\Sigma \vdash\text{Constr}_k:(\Gamma_k,y:A_k[\mu/X])\rightarrow\mu@\sigma_k}$}}
     \noLine
     \UnaryInfC{$\overrightarrow{\Delta,\Gamma_k,y_k:A_k[C/X]\vdash g_k:\text{\colorbox{gray}{$B_k$}}}$}
     \RightLabel{\textbf{(Ind-E)}}
     \TrinaryInfC{\colorbox{gray}{$\Sigma|\Theta|$}$\Delta\vdash$ rec \colorbox{gray}{$\mu$ to C};
       $\overrightarrow{\text{Constr}_k\overrightarrow{x_k}\text{ } y_k = g_k}:(\Gamma,y:\mu@id_\Gamma)\rightarrow C@id_\Gamma$}
    \end{prooftree}


** Corecursion
   \begin{center}
     \AxiomC{$\vdash C:\Gamma\rightarrow*$}
     \AxiomC{$\Delta,\Gamma_k,y_k:(C@\sigma_k)\vdash g_k:A_k[C/X]$}
     \AxiomC{$\forall k=1,\dots,n$}
     \RightLabel{\textbf{(Coind-I)}}
     \TrinaryInfC{$\Delta\vdash$ corec
       $\overrightarrow{(\Gamma_k,y_k).g_k}:(\Gamma,y:C@id_\Gamma)\rightarrow \nu@id_\Gamma$}
     \DisplayProof
   \end{center}

   \begin{prooftree}
     \AxiomC{$\vdash C:\Gamma\rightarrow*$}
     \AxiomC{\colorbox{gray}{$\overrightarrow{\vdash B_k\equiv_\beta A_k[C/X]}$}}
     \AxiomC{\colorbox{gray}{$\overrightarrow{\Sigma \vdash\text{Destr}_k:(\Gamma_k,y:\nu@\sigma_k)\rightarrow
       A_k[\nu/X]}$}}
     \noLine
     \UnaryInfC{$\overrightarrow{\Delta,\Gamma_k,y_k:(\Gamma_k,y:(C@\sigma_k))\vdash g_k:\text{\colorbox{gray}{$B_k$}}}$}
     \RightLabel{\textbf{(Coind-I)}}
     \TrinaryInfC{\colorbox{gray}{$\Sigma|\Theta|$}$\Delta\vdash$ rec \colorbox{gray}{C to $\nu$};
       $\overrightarrow{\text{Destr}_k\overrightarrow{x_k}\text{ } y_k = g_k}:(\Gamma,y:C@id_\Gamma)\rightarrow \nu@id_\Gamma$}
    \end{prooftree}
